

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Python并行计算 &mdash; 7125MESSI&#39;s BLOG 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Spark分布式计算" href="Spark%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html" />
    <link rel="prev" title="Welcome to 7125MESSI’s BLOG’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> 7125MESSI's BLOG
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python并行计算</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#threadpoolexecutor-i-o">1 通过线程池 ThreadPoolExecutor 用多线程做并发（提升有限，I/O密集型）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#processpoolexecutor-i-ocpu">2 通过线程池 ProcessPoolExecutor 用多进程做并发（I/O、CPU密集型）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#joblibpython">3 <strong>使用Joblib并行运行Python代码</strong>（实际工程中比较好用）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">4 案例介绍</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Spark%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html">Spark分布式计算</a></li>
<li class="toctree-l1"><a class="reference internal" href="Spark%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.html">Spark性能调优</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">7125MESSI's BLOG</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Python并行计算</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/Python并行计算.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="python">
<h1>Python并行计算<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Date</dt>
<dd class="field-odd"><p>2021-10-16T14:34:09+08:00</p>
</dd>
</dl>
<p>[参考文献]</p>
<ul class="simple">
<li><p>《Effective Python：编写高质量Python代码的90个有效方法（原书第2版）》</p></li>
</ul>
<p>并发（concurrency）指计算机似乎能在同一时刻做许多件不同的事情。例如，在只配有一个CPU核心的计算机上面，操作系统可以迅速切换这个处理器所运行的程序，因此尽管同一时刻最多只有一个程序在运行，但这些程序能够交替地使用这个核心，从而造成一种假象，让人觉得它们好像真的在同时运行。</p>
<p>并行（parallelism）与并发的区别在于，它强调计算机确实能够在同一时刻做许多件不同的事情。例如，若计算机配有多个CPU核心，那么它就真的可以同时执行多个程序。每个CPU核心执行的都是自己的那个程序之中的指令，这些程序能够同时向前推进。</p>
<p>在同一个程序之中，我们可以利用并发轻松地解决某些类型的问题。例如，并发可以让程序里面出现多条独立的执行路径，每条路径都可以处理它自己的I/O流，这就让我们觉得这些I/O任务好像真的是在各自的路径里面同时向前推进的。</p>
<p>并行与并发之间的区别，关键在于能不能提速（speedup）。如果程序把总任务量分给两条独立的执行路径去同时处理，而且这样做确实能让总时间下降到原来的一半，那么这就是并行，此时的总速度是原来的两倍。反过来说，假如无法实现加速，那即便程序里有一千条独立的执行路径，也只能叫作并发，因为这些路径虽然看起来是在同时推进，但实际上却没有产生相应的提速效果。</p>
<p>Python让我们很容易就能写出各种风格的并发程序。在并发量较小的场合可以使用线程（thread），如果要运行大量的并发函数，那么可以使用协程（coroutine）。</p>
<p>并行任务，可以通过系统调用、子进程与C语言扩展（Cextension）来实现，但要写出真正能够并行的Python代码，其实是很困难的。</p>
<p>●
即便计算机具备多核的CPU，Python线程也无法真正实现并行，因为它们会受全局解释器锁（GIL）牵制。</p>
<p>●
虽然Python的多线程机制受GIL影响，但还是非常有用的，因为我们很容易就能通过多线程模拟同时执行多项任务的效果。</p>
<p>●
多条Python线程可以并行地执行多个系统调用，这样就能让程序在执行阻塞式的I/O任务时，继续做其他运算。</p>
<p>● 虽然Python有全局解释器锁，但开发者还是得设法避免线程之间发生数据争用。</p>
<p>●
把未经互斥锁保护的数据开放给多个线程去同时修改，可能导致这份数据的结构遭到破坏。</p>
<p>●
可以利用threading内置模块之中的Lock类确保程序中的固定关系不会在多线程环境下受到干扰。</p>
<p>● 程序范围变大、需求变复杂之后，经常要用多条路径平行地处理任务。</p>
<p>● fan-out与fan-in是最常见的两种并发协调（concurrency
coordination）模式，前者用来生成一批新的并发单元，后者用来等待现有的并发单元全部完工。（分派–归集）</p>
<p>● Python提供了很多种实现fan-out与fan-in的方案。</p>
<p>但是： ●
每次都手工创建一批线程，是有很多缺点的，例如：创建并运行大量线程时的开销比较大，每条线程的内存占用量比较多，而且还必须采用Lock等机制来协调这些线程。</p>
<p>●
线程本身并不会把执行过程中遇到的异常抛给启动线程或者等待该线程完工的那个人，所以这种异常很难调试。</p>
<div class="section" id="threadpoolexecutor-i-o">
<span id="threadpoolexecutor-io"></span><h2>1 通过线程池 ThreadPoolExecutor 用多线程做并发（提升有限，I/O密集型）<a class="headerlink" href="#threadpoolexecutor-i-o" title="Permalink to this headline">¶</a></h2>
<p><strong>Python有个内置模块叫作concurrent.futures，它提供了ThreadPoolExecutor类。</strong>
<strong>这个类结合了线程（Thread）方案与队列（Queue）方案的优势，可以用来平行地处理
I/O密集型操作。</strong></p>
<p>ThreadPoolExecutor方案仍然有个很大的缺点，就是I/O并行能力不高，即便把max_workers设成100，也无法高效地应对那种有一万多个单元格，且每个单元格都要同时做I/O的情况。如果你面对的需求，没办法用异步方案解决，而是必须执行完才能往后走（例如文件I/O），那么ThreadPoolExecutor是个不错的选择。然而在许多情况下，其实还有并行能力更强的办法可以考虑。</p>
<p>利用ThreadPoolExecutor，我们只需要稍微调整一下代码，就能够并行地执行简单的I/O操作，这种方案省去了每次fan-out（分派）任务时启动线程的那些开销。</p>
<p>虽然ThreadPoolExecutor不像直接启动线程的方案那样，需要消耗大量内存，但它的I/O并行能力也是有限的。因为它能够使用的最大线程数需要提前通过max_workers参数指定。</p>
</div>
<div class="section" id="processpoolexecutor-i-ocpu">
<span id="processpoolexecutor-iocpu"></span><h2>2 通过线程池 ProcessPoolExecutor 用多进程做并发（I/O、CPU密集型）<a class="headerlink" href="#processpoolexecutor-i-ocpu" title="Permalink to this headline">¶</a></h2>
<p>从开发者这边来看，这个过程似乎很简单，但实际上，multiprocessing模块与
ProcessPoolExecutor类要做大量的工作才能实现出这样的并行效果。同样的效果，假如改用其他语言来做，那基本上只需要用一把锁或一项原子操作就能很好地协调多个线程，从而实现并行。<strong>但这在Python里面不行，所以我们才考虑通过ProcessPoolExecutor来实现。然而这样做的开销很大，因为它必须在上级进程与子进程之间做全套的序列化与反序列化处理。这个方案对那种孤立的而且数据利用度较高的任务来说，比较合适。</strong></p>
<p><strong>●
所谓孤立（isolated），这里指每一部分任务都不需要跟程序里的其他部分共用状态信息。</strong>
<strong>●
所谓数据利用度较高（high-leverage），这里指任务所使用的原始材料以及最终所给出的结果数据量都很小，因此上级进程与子进程之间只需要互传很少的信息就行，然而在把原始材料加工成最终产品的过程中，却需要做大量运算。刚才那个求最大公约数的任务就属于这样的例子，当然还有很多涉及其他数学算法的任务，也是如此。</strong></p>
<p>如果你面对的计算任务不具备刚才那两项特征，那么使用ProcessPoolExecutor所引发的开销可能就会盖过因为并行而带来的好处。在这种情况下，我们可以考虑直接使用multiprocessing所提供的一些其他高级功能，例如共享内存（shared
memory）、跨进程的锁（cross-process
lock）、队列（queue）以及代理（proxy）等。但是，这些功能都相当复杂，即便两个Python线程之间所要共享的进程只有一条，也是要花很大工夫才能在内存空间里面将这些工具安排到位。假如需要共享的进程有很多条，而且还涉及socket，那么这种代码理解起来会更加困难。</p>
<p>总之，不要刚一上来，就立刻使用跟multiprocessing这个内置模块有关的机制，而是可以先试着用ThreadPoolExecutor来运行这种孤立且数据利用度较高的任务。把这套方案实现出来之后，再考虑向ProcessPoolExecutor方案迁移。如果ProcessPoolExecutor方案也无法满足要求，而且其他办法也全都试遍了，那么最后可以考虑直接使用multiprocessing模块里的高级功能来编写代码。</p>
<p>●
把需要耗费大量CPU资源的计算任务改用C扩展模块来写，或许能够有效提高程序的运行速度，同时又让程序里的其他代码依然能够利用Python语言自身的特性。但是，这样做的开销比较大，而且容易引入bug。</p>
<p>●
Python自带的multiprocessing模块提供了许多强大的工具，让我们只需要耗费很少的精力，就可以把某些类型的任务平行地放在多个CPU核心上面处理。要想发挥出multiprocessing模块的优势，最好是通过concurrent.futures模块及其ProcessPoolExecutor类来编写代码，因为这样做比较简单。</p>
<p>●
只有在其他方案全都无效的情况下，才可以考虑直接使用multiprocessing里面的高级功能（那些功能用起来相当复杂）。</p>
</div>
<div class="section" id="joblibpython">
<span id="id1"></span><h2>3 <strong>使用Joblib并行运行Python代码</strong>（实际工程中比较好用）<a class="headerlink" href="#joblibpython" title="Permalink to this headline">¶</a></h2>
<p>对于大多数问题，并行计算确实可以提高计算速度。
随着PC计算能力的提高，我们可以通过在PC中运行并行代码来简单地提升计算速度。<a class="reference external" href="https://link.zhihu.com/?target=https%3A//joblib.readthedocs.io/en/latest/">Joblib</a>就是这样一个可以简单地将P<strong>ython代码转换为并行计算模式的软件包，它可非常简单并行我们的程序，从而提高计算速度。</strong></p>
<p><a class="reference external" href="https://link.zhihu.com/?target=https%3A//joblib.readthedocs.io/en/latest/">Joblib</a>是一组用于在Python中提供轻量级流水线的工具。
它具有以下功能：</p>
<ul class="simple">
<li><p>透明的磁盘缓存功能和“懒惰”执行模式，简单的并行计算</p></li>
<li><p>Joblib对numpy大型数组进行了特定的优化，简单，快速。</p></li>
</ul>
<p>除了并行计算功能外，Joblib还具有以下功能：</p>
<ul class="simple">
<li><p>快速磁盘缓存：Python函数的memoize或make-like功能，适用于任意Python对象，包括大型numpy数组。</p></li>
<li><p>快速压缩：替代pickle，使用joblib.dump和joblib.load可以提高大数据的读取和存储效率。</p></li>
</ul>
<p>以下我们使用一个简单的例子来说明如何利用Joblib实现并行计算。
我们使用单个参数<code class="docutils literal notranslate"><span class="pre">i</span></code>定义一个简单的函数<code class="docutils literal notranslate"><span class="pre">my_fun()</span></code>。
此函数将等待1秒，然后计算<code class="docutils literal notranslate"><span class="pre">i**2</span></code>的平方根，也就是返回<code class="docutils literal notranslate"><span class="pre">i</span></code>本身。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">my_fun</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; We define a simple function here.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>这里我们将总迭代次数设置为10.我们使用<code class="docutils literal notranslate"><span class="pre">time.time()</span></code>函数来计算<code class="docutils literal notranslate"><span class="pre">my_fun()</span></code>的运行时间。
如果使用简单的for循环，计算时间约为10秒。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">my_fun</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.4f}</span><span class="s1"> s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>

<span class="c1"># 10.0387 s</span>
</pre></div>
</div>
<p>使用Joblib中的<code class="docutils literal notranslate"><span class="pre">Parallel</span></code>和<code class="docutils literal notranslate"><span class="pre">delayed</span></code>函数，我们可以简单地配置<code class="docutils literal notranslate"><span class="pre">my_fun()</span></code>函数的并行运行。
其中我们会用到几个参数，<code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>是并行作业的数量，我们在这里将它设置为<code class="docutils literal notranslate"><span class="pre">2</span></code>。
<code class="docutils literal notranslate"><span class="pre">i</span></code>是<code class="docutils literal notranslate"><span class="pre">my_fun()</span></code>函数的输入参数，依然是10次迭代。两个并行任务给节约了大约一半的for循环运行时间，结果并行大约需要5秒。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="c1"># n_jobs is the number of parallel jobs</span>
<span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">my_fun</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.4f}</span><span class="s1"> s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>

<span class="c1"># 5.6560 s</span>
</pre></div>
</div>
<p>就是这么简单！ 如果我们的函数中有多个参数怎么办？ 也很简单。
让我们用两个参数定义一个新函数<code class="docutils literal notranslate"><span class="pre">my_fun_2p(i,j)</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_fun_2p</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; We define a simple function with two parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="n">j</span><span class="p">)</span>

<span class="n">j_num</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j_num</span><span class="p">):</span>
        <span class="n">my_fun_2p</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.4f}</span><span class="s1"> s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>

<span class="c1"># 30.0778 s</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="c1"># n_jobs is the number of parallel jobs</span>
<span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">my_fun_2p</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j_num</span><span class="p">))</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.4f}</span><span class="s1"> s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>

<span class="c1"># 15.0622 s</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<span id="id3"></span><h2>4 案例介绍<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>这里用了偏函数，执行主函数 data_preprocessor，生成 偏函数
data_preprocessor_p；</p></li>
<li><p>apply_parallel, 就是用Joblib定义的并行计算函数，目前支持 pandas
dataframe的func根据分组后数据并行计算再归并。</p></li>
<li><p>对于其他数据类型，可以参考 parmap函数</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">from</span> <span class="nn">model.month.offline_lgb_city_model</span> <span class="kn">import</span> <span class="n">LgbCityModel</span>

<span class="kn">from</span> <span class="nn">utils.multi_processor</span> <span class="kn">import</span> <span class="n">apply_parallel</span>

<span class="o">......</span>

<span class="n">lgbmodel</span> <span class="o">=</span> <span class="n">LgbCityModel</span><span class="p">()</span>

<span class="c1"># 数据预处理并保存文件</span>
<span class="k">def</span> <span class="nf">data_preprocessor</span><span class="p">(</span><span class="n">sales_month</span><span class="p">,</span> <span class="n">lgbmodel</span><span class="p">,</span> <span class="n">master_data</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">upper_division</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">lgbmodel</span><span class="o">.</span><span class="n">_preproces</span><span class="p">(</span><span class="n">sales_month</span><span class="p">,</span> <span class="n">master_data</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">upper_division</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="n">data_preprocessor_p</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">data_preprocessor</span><span class="p">,</span>
                              <span class="n">lgbmodel</span><span class="o">=</span><span class="n">lgbmodel</span><span class="p">,</span>
                              <span class="n">master_data</span><span class="o">=</span><span class="n">master_data</span><span class="p">,</span>
                              <span class="n">division</span><span class="o">=</span><span class="n">division</span><span class="p">,</span>
                              <span class="n">upper_division</span><span class="o">=</span><span class="n">upper_division</span><span class="p">)</span>
<span class="n">processor_data</span> <span class="o">=</span> <span class="n">apply_parallel</span><span class="p">(</span><span class="n">sales_lgb</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">),</span> <span class="n">data_preprocessor_p</span><span class="p">)</span>
<span class="n">processor_data</span> <span class="o">=</span> <span class="n">lgbmodel</span><span class="o">.</span><span class="n">_memory_process</span><span class="p">(</span><span class="n">processor_data</span><span class="p">)</span>
<span class="n">processor_data</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;data/preprocessed/preprocessed_lgb_</span><span class="si">{</span><span class="n">division</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">run_time</span><span class="si">}</span><span class="s1">.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="k">def</span> <span class="nf">apply_parallel</span><span class="p">(</span><span class="n">df_grouped</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    与上边不同的是，他直接传递给子进程 分片数据，而不是分片索引</span>
<span class="sd">    注意：该函数不是通用函数，只针对返回 pandas dataframe的func</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_grouped：分片数据列表</span>
<span class="sd">    func：表调用的函数</span>

<span class="sd">    Returns: dataframe</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df_grouped</span><span class="p">)</span>
    <span class="c1"># 过滤空的结果</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
    <span class="c1"># 否则index 有重复</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">q_in</span><span class="p">,</span> <span class="n">q_out</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    从blocking queue_in 中获取数据</span>
<span class="sd">    把结果保存到 blocking queue_out</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f</span>
<span class="sd">    q_in</span>
<span class="sd">    q_out</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">q_in</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">q_out</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">parmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1.主进程将数据按照索引分片推送如队列 q_in，最后将结束符号推入队列。blocking</span>
<span class="sd">    2.工作进程进程从q_in取索引 调用回调方法;如果去除的数据是结束符，则进程结束</span>
<span class="sd">    3.每个进行运算结果放入结果队列q_out</span>
<span class="sd">    4.获取每个&quot;分片&quot;的返回数据,按照传入的数据排序，然后返回</span>
<span class="sd">    注意：windows 下不能运行</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f ：回调函数，每个子进程调用这个函数，传入索引分片</span>
<span class="sd">    X ：数组，每个元素是索引的数组</span>
<span class="sd">    nprocs：子进程个数</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q_in</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">q_out</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="c1"># 创建工作进程</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="p">[</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">fun</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">q_in</span><span class="p">,</span> <span class="n">q_out</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocs</span><span class="p">)]</span>
    <span class="c1"># 每个工作进程当成守护进行，主线程结束，子线程跟着结束</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="p">[</span><span class="n">q_in</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X</span><span class="p">)]</span>
    <span class="c1"># 结束标记</span>
    <span class="p">[</span><span class="n">q_in</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocs</span><span class="p">)]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">q_out</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">))]</span>
    <span class="c1"># 等待每个工作线程结束</span>
    <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">res</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Spark%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html" class="btn btn-neutral float-right" title="Spark分布式计算" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to 7125MESSI’s BLOG’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>